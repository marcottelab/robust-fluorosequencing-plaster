"""sim v3 worker code. adding flexibility to virtual fluorosequencing (VFS) methods."""

from dataclasses import dataclass
from typing import Sequence

import numpy as np
from dataclasses_json import DataClassJsonMixin

import plaster.run.sim_v2.c_radsim.radsim_v2 as radsim_v2
import plaster.run.sim_v2.dyt_helpers as dyt_helpers
import plaster.run.sim_v2.sim_v2_params as sim_v2_params


@dataclass
class FretInteraction(DataClassJsonMixin):
    """Class representing a FRET interaction.

    Attributes
    ----------
    donor: int
        The donor dye channel. This channel loses intensity as a result of
        interactions with the acceptor channel.
    acceptor: int
        The acceptor dye channel. This channel is currently unaffected by
        FRET, since we do not currently observe acceptors during donor
        illumination.
    factor: float
        The factor by which donor dyes will be multiplied in the presence
        of acceptor dye(s)
    flat: bool (default=True)
        If True, the FRET factor will be applied to donors once if any
        acceptors or quenching donors are present. If False, the FRET
        factor will be applied once per acceptor or quenching donor, and
        the total FRET effect will be = factor ** n_acceptors.
    """

    donor: int
    acceptor: int
    factor: float
    flat: bool = True


def fret_mod(
    dyetrack: np.ndarray, fret_interactions: Sequence[FretInteraction]
) -> np.ndarray:
    """Model FRET effects on a dyetrack.

    Given a dyetrack, return a new dyetrack with donor dye intensities
    modified by a FRET factor during cycles where acceptor dyes are present.

    Args
    ----
    dyetrack: np.ndarray
        The input dyetrack.
    fret_interactions: Sequence[FretInteraction]
        A Sequence that uses FretInteraction objects to describe FRET
        effects on the system. Donor channel intensities will be reduced by
        FretInteraction.factor while dyes are present in the acceptor channel.
        All FretInteractions will be applied in order.
        Note that self-quenching interactions can be modeled by specifying
        the same channel for donor and acceptor. In this case, donor intensity
        will be reduced as long as >1 dye is present in the channel.

    Returns
    -------
    A FRET-modified output dyetrack of the same shape as the input dyetrack.

    """
    new_dyetrack = dyetrack.astype(float)
    for item in fret_interactions:
        if item.donor == item.acceptor:
            if item.flat:
                new_dyetrack[item.donor, :] = new_dyetrack[item.donor, :] * (
                    item.factor ** (dyetrack[item.acceptor, :] > 1)
                )
            else:
                new_dyetrack[item.donor, :] = new_dyetrack[item.donor, :] * (
                    item.factor ** np.maximum((dyetrack[item.acceptor, :] - 1.0), 0.0)
                )
        else:
            if item.flat:
                new_dyetrack[item.donor, :] = new_dyetrack[item.donor, :] * (
                    item.factor ** (dyetrack[item.acceptor, :] > 0)
                )
            else:
                new_dyetrack[item.donor, :] = new_dyetrack[item.donor, :] * (
                    item.factor ** dyetrack[item.acceptor, :]
                )
    return new_dyetrack


def _radmat_sim_v3(
    dytmat_cube: np.ndarray,
    dytpeps: np.ndarray,
    sim_params: sim_v2_params.SimV2Params,
    n_samples: int,
    out_radmat: np.ndarray,
    out_row_ks: np.ndarray,
    out_dyt_iz: np.ndarray,
    out_pep_iz: np.ndarray,
    *,
    skip_resample: bool = True,
):
    """Convert a dyetrack matrix (peptide dye counts per channel) and
    dyetrack-peptide list generated in the simulator into a radiometry matrix
    (observed intensity per channel). Models microscopy processes and dye-dye
    interactions such as FRET.

    Args
    ----
    dytmat_cube: np.ndarray
        Input dyetrack matrix. 3D representation of observed dyetracks whose
        dimensions are:
            0: n_dyetracks
            1: n_channels (observation wavelengths)
            2: n_cycles (number of chemical cycles that perturb the peptides).
        These dyetracks will be transformed into radiometry matrices according
        to the statistical information in dytpeps.
    dytpeps: np.ndarray
        Dyetrack-peptide matrix. Correlates dyetracks in dytmat_cube with peptides
        generated by the input to the simulator and counts the number of times each
        peptide generated each dyetrack. Columns are:
            0: Dyetrack (dim 0 in dytmat_cube)
            1: Peptide index (referencing peptides supplied to dytmat generation)
            2: Counts of dyetracks generated by each peptide
    sim_params: sim_v2_params.SimV2Params
        Contains error parameters and FRET interaction info for radiometry sims.
    n_samples: int
        Number of times each peptide will be sampled. Specified in sim_params
        for n_samples_train and n_samples_test. Must be equal to the number of
        counts generated for each peptide in dytpeps.
        TODO: Replace with counts observed from dytpeps.
    out_radmat: np.ndarray
        Predefined array for radmat results. Must be 3D and have dimensions
            0: n_peptides * n_samples
            1: n_channels
            2: n_cycles
    out_row_ks: np.ndarray
        Predefined array of length n_peptides * n_samples containing the row_k
        row intensity modification for each radmat row. (This is a model of
        experimental error from earlier methods and may be deprecated at some
        future point.)
    out_dyt_iz: np.ndarray
        Predefined array of length n_peptides * n_samples containing the index of
        the dyetrack that generated each radiometry row.
    out_pep_iz: np.ndarray
        Predefined array of length n_peptides * n_samples containing the index of
        the peptide that generated each radiometry row.
    skip_resample: bool = True
        It was once true that normally the dytpeps were resampled based on their
        proportion in each peptide prior to generation of the radiometry matrix.
        But the default behavior of the dytsim is to generate the requested n_samples
        unless the peptide is completely dark, so resampling is not really necessary.
        If False, then do resample anyway.
    """

    rng = np.random.default_rng()

    assert len(dytmat_cube.shape) == 3
    assert len(dytpeps.shape) == 2

    sorted_dytpeps = dyt_helpers.sort_dytpeps(dytpeps)

    if skip_resample:
        resampled_dytpeps = sorted_dytpeps
    else:
        resampled_dytpeps = radsim_v2.c_pep_sample(
            sorted_dytpeps, n_samples, progress=None
        )

    # set up rng shape arrays
    gain_mu = np.stack(
        [
            mu.value * np.ones((n_samples, dytmat_cube.shape[2]))
            for mu in sim_params._channel__priors.gain_mu
        ],
        axis=1,
    )
    gain_sigma = np.stack(
        [
            sigma.value * np.ones((n_samples, dytmat_cube.shape[2]))
            for sigma in sim_params._channel__priors.gain_sigma
        ],
        axis=1,
    )

    bg_mu = np.stack(
        [
            mu.value * np.ones((n_samples, dytmat_cube.shape[2]))
            for mu in sim_params._channel__priors.bg_mu
        ],
        axis=1,
    )
    bg_sigma = np.stack(
        [
            sigma.value * np.ones((n_samples, dytmat_cube.shape[2]))
            for sigma in sim_params._channel__priors.bg_sigma
        ],
        axis=1,
    )

    row_k_mu = np.ones(gain_mu.shape[0])
    row_k_sigma = (
        np.ones(gain_mu.shape[0]) * sim_params.priors.get("row_k_sigma").prior.value
    )

    # generate dyetracks
    collector = {}
    accum_idx = 0
    # skip resampled_dytpeps row 0
    # iterating over the dytpep matrix
    for dytpep_idx in range(1, resampled_dytpeps.shape[0]):

        dytmat_idx, pep_idx, pep_count = resampled_dytpeps[dytpep_idx, :]

        # apply FRET modifications
        this_dyetrack = fret_mod(
            dytmat_cube[dytmat_idx, :, :], sim_params.fret_interactions
        )

        if pep_idx not in collector:
            collector[pep_idx] = []

        for _ in range(pep_count):
            collector[pep_idx].append(this_dyetrack)
            out_dyt_iz[accum_idx] = dytmat_idx
            out_pep_iz[accum_idx] = pep_idx
            accum_idx = accum_idx + 1

    # take the FRET modified dyetracks and apply noise perturbations on them
    for index, k in enumerate(collector):
        row_ks = rng.normal(row_k_mu, row_k_sigma)
        # np.newaxis helps broadcast
        out_radmat[(index * n_samples) : ((index + 1) * n_samples), :, :] = row_ks[
            :, np.newaxis, np.newaxis
        ] * (
            np.stack(collector[k]) * rng.normal(gain_mu, gain_sigma)
            + rng.normal(bg_mu, bg_sigma)
        )
        out_row_ks[(index * n_samples) : ((index + 1) * n_samples)] = row_ks
