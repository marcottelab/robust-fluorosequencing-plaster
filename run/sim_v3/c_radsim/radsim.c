#include "alloca.h"
#include "inttypes.h"
#include "math.h"
#include "memory.h"
#include "pthread.h"
#include "signal.h"
#include "stdarg.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"
#include "c_common.h"
#include "radsim.h"

/*
This is the radiometry simulator phase of plaster implemented in C.

Inputs (see typedef SimV3Context in sim.h):
    * An array of dyetracks (dytmat) and an array of n_samples_per_dyt

Outputs
    * An array of radiometry samples n_samples_per_dyt * n_dyts
    * A parallel array of row_k values.
*/

int setup_and_sanity_check(RNG *rng, Size n_channels, Size n_cycles) {
    // Setup the hashkey_factors with random numbers and
    // Check that the compiler sizes are what is expected.
    // return 0 == success

    if(rng_p_i(rng, UINT64_MAX) != 1) {
        printf("Failed sanity check: rng_p_i\n");
        return 6;
    }

    return 0;
}

// RadSim
//=========================================================================================

void _dyt_to_rad(
    RadSimContext *ctx, RNG *rng, Uint8 *dyt, RadType *out_radrow,
    RowKType *out_row_k) {
    // Generate a single radiometry row for a given dyetrack, including the
    // row_k factor

    Size n_channels = ctx->n_channels;
    Size n_cycles = ctx->n_cycles;

    RowKType row_k = rng_normal(rng, 1.0, ctx->row_k_sigma);
    *out_row_k = row_k;

    Index i = 0;
    for(Index ch_i = 0; ch_i < n_channels; ch_i++) {
        // TODO: Eventually this needs to sample from the priors instead of the
        // MLE.
        ChIllumPriors *priors =
            tab_ptr(ChIllumPriors, &ctx->ch_illum_priors, ch_i);
        const Float64 gain_mu = priors->gain_mu;
        const Float64 gain_var = priors->gain_sigma * priors->gain_sigma;
        const Float64 bg_mu = priors->bg_mu;
        const Float64 bg_var = priors->bg_sigma * priors->bg_sigma;

        if(ctx->use_lognormal_model) {
            for(Index cy_i = 0; cy_i < n_cycles; cy_i++) {
                const Float64 dyt_count = (Float64)dyt[i];
                Float64 sigma = priors->gain_sigma;
                Float64 rad = rng_lognormal(rng, dyt_count * gain_mu, sigma);
                out_radrow[i] = (RadType)rad * row_k;
                i++;
            }
        } else {
            for(Index cy_i = 0; cy_i < n_cycles; cy_i++) {
                const Float64 dyt_count = (Float64)dyt[i];
                Float64 sigma = sqrt(dyt_count * gain_var + bg_var);
                Float64 rad = rng_normal(rng, dyt_count * gain_mu, sigma);
                out_radrow[i] = (RadType)rad * row_k;
                i++;
            }
        }
    }
}

char *radsim_batch(
    RadSimContext *ctx, RNG *rng, Index start_dytpep_i, Index stop_dytpep_i) {
    check_and_return(
        stop_dytpep_i > start_dytpep_i,
        "stop_dytpep_i must be > start_dytpep_i");
    for(Index dytpep_i = start_dytpep_i; dytpep_i < stop_dytpep_i; dytpep_i++) {
        check_and_return(
            dytpep_i > 0, "dytpep_i == 0 is not allowed in radsim_batch");

        // Index into dytpep_i - 1 because the dytpep_i_to_out_i is built
        // Using a cumsum and record [0] is always zero so:
        // [0, 10, 5] means that the index of dytpep_i==1 is 0.
        Index out_i = *u32arr_ptr1(&ctx->dytpep_i_to_out_i, dytpep_i - 1);

        DytPepRec *dytpep_rec =
            (DytPepRec *)u32arr_ptr1(&ctx->dytpeps, dytpep_i);

        Size dyt_i = (Size)dytpep_rec->dyt_i;
        check_and_return(dyt_i > 0, "dytpep dyt_i == 0 not allowed.");

        DytPepType pep_i = dytpep_rec->pep_i;
        Size n_samples = (Size)dytpep_rec->n_reads;

        for(Index samp_i = 0; samp_i < n_samples; samp_i++) {
            _dyt_to_rad(
                ctx, rng, u8arr_ptr1(&ctx->dytmat, dyt_i),
                f32arr_ptr1(&ctx->out_radmat, out_i),
                f32arr_ptr1(&ctx->out_row_ks, out_i));

            *u32arr_ptr1(&ctx->out_dyt_iz, out_i) = dyt_i;
            *u32arr_ptr1(&ctx->out_pep_iz, out_i) = pep_i;

            out_i += 1;
        }
    }

    return NULL;
}

char *radsim_context_init(RadSimContext *ctx) {
    // Sanity check
    RNG rng; // A placeholder rng during sanity test
    check_and_return(
        setup_and_sanity_check(&rng, ctx->n_channels, ctx->n_cycles) == 0,
        "Sanity checks failed");

    return NULL;
}

char *radsim_context_free(RadSimContext *ctx) {
    return NULL;
}

// PepSample
//=========================================================================================

char *sample_pep(
    SamplePepsContext *ctx, RNG *rng, Index start_pep_i, Index stop_pep_i) {
    /*
    dytpeps is a table like:
        [
            [1, 2, 500],  // dyt 1 was generated by pep 2 500 times
            [2, 2, 500],  // dyt 2 was generated by pep 2 500 times
            [1, 3, 100],  // dyt 1 was generated by pep 3 100 times
            [3, 3, 900],  // dyt 3 was generated by pep 3 900 times
        ]

    out_dytpeps is a copy of this table with the count column [2] set to zeros.

    This function resamples from this table so that each peptide is sampled
    the same number of times and writes that into the out_dytpeps.

    Note, stop_pep_i is EXCLUSIVE.
    */

    const int dytpep_dyt_column = 0;
    const int dytpep_pep_column = 1;
    const int dytpep_count_column = 2;

    Size n_samples_per_pep = ctx->n_samples_per_pep;

    for(Index pep_i = start_pep_i; pep_i < stop_pep_i; pep_i++) {
        Index start_dytpep_i = *u32arr_ptr1(&ctx->pep_i_to_dytpep_i, pep_i);

        Size n_dytpeps = *u32arr_ptr1(&ctx->pep_i_to_n_dytpeps, pep_i);
        check_and_return(
            n_dytpeps < 1000000,
            "n_dytpeps is too large. pep_i_to_dytpep_i is likely corrupt");

        Index stop_dytpep_i = start_dytpep_i + n_dytpeps;

        if(start_dytpep_i >= 0 && n_dytpeps > 0) {
            check_and_return(stop_dytpep_i > 0, "stop_dytpep_i size is wrong");
            check_and_return(
                stop_dytpep_i >= start_dytpep_i,
                "stop_dytpep_i must be >= than start. pep_i_to_dytpep_i is "
                "likely corrupt");

            Uint32 weight_sum = 0;
            for(Index dytpep_i = start_dytpep_i; dytpep_i < stop_dytpep_i;
                dytpep_i++) {
                weight_sum +=
                    *u32arr_ptr2(&ctx->dytpeps, dytpep_i, dytpep_count_column);
            }

            if(weight_sum == 0) {
                continue;
            }

            for(Index samp_i = 0; samp_i < n_samples_per_pep; samp_i++) {
                // Random choose a dyetrack proportional to the weight

                Uint64 r = rng_uint64(rng) % weight_sum;

                // Given how few dytpeps there are likely to be per pep I think
                // it is probably fastest to linear search the weights looking
                // to pass the cumulative sum of r. If these lists get too large
                // then it might be more efficient to use a binary search
                // (bsearch stdlib)
                Uint32 running_sum = 0;
                Index selected_dytpep_i = 0;
                for(Index dytpep_i = start_dytpep_i; dytpep_i < stop_dytpep_i;
                    dytpep_i++) {
                    Uint32 weight = *u32arr_ptr2(
                        &ctx->dytpeps, dytpep_i, dytpep_count_column);
                    if(running_sum + weight > r) {
                        selected_dytpep_i = dytpep_i;
                        break;
                    }
                    running_sum += weight;
                }

                check_and_return(
                    start_dytpep_i <= selected_dytpep_i &&
                        selected_dytpep_i < stop_dytpep_i,
                    "selected_row out of bounds");

                *u32arr_ptr2(
                    &ctx->out_dytpeps, selected_dytpep_i,
                    dytpep_count_column) += 1;
            }
        }
    }

    return NULL;
}

char *sample_peps_context_init(SamplePepsContext *ctx) {
    /*
    dytpeps is an array table like:
        [
            [0, 0, 0],
            [2, 1, 10],
            [3, 1, 10],
            [2, 2, 20],
        ]
    Where first column is dyt_im second is pep_i and thrid is count.

    We scan the dytpeps table looking for boundaries between pep_i
    And write these into a lookup table so that we can go from
    pep_i to dytpep_i quickly.

    It is expected that some peptides will have no labels
    and therefore will have no dyts and thus their lookup will be to zero.
    Thus we have to handle this case.

    The output of this functino is written into two parallel arrays:
    pep_i_to_dytpep_i and pep_i_to_n_dytpeps

    Assumes (and asserts) that dytpeps is sorted by pep_i.
    */

    check_and_return(ctx->dytpeps.n_dims == 2, "dytpeps expects 2 dims");
    check_and_return(ctx->dytpeps.shape[1] == 3, "dytpeps expects 3 columns");

    DytPepRec *row_zero = (DytPepRec *)u32arr_ptr1(&ctx->dytpeps, 0);

    // dytpeps need to start with a reserved row to keep counting simple
    check_and_return(row_zero->dyt_i == 0, "dytpeps first row must be dyt 0");
    check_and_return(row_zero->pep_i == 0, "dytpeps first row must be pep 0");
    check_and_return(
        row_zero->n_reads == 0, "dytpeps first row must be n_reads 0");

    Size n_dytpeps = ctx->dytpeps.shape[0];

    DytPepType last_pep_i = 0;
    Index last_pep_i_start_dytpep_i = 0;

    for(Index dytpep_i = 0; dytpep_i < n_dytpeps; dytpep_i++) {
        DytPepType curr_pep_i =
            ((DytPepRec *)u32arr_ptr1(&ctx->dytpeps, dytpep_i))->pep_i;
        if(curr_pep_i != last_pep_i) {
            // We just hit a pep_i boundary in the dytpeps table.
            // Note it might not be the next pep_i because a peptide can have
            // zero dyts. But it is the end of the last_pep_i we were scanning.
            check_and_return(
                curr_pep_i > last_pep_i || last_pep_i == -1,
                "dytpeps is not sorted by pep_i");

            // Note start index of new pep_i
            *u32arr_ptr1(&ctx->pep_i_to_dytpep_i, curr_pep_i) = dytpep_i;

            // Note length of last_pep_i
            *u32arr_ptr1(&ctx->pep_i_to_n_dytpeps, last_pep_i) =
                dytpep_i - last_pep_i_start_dytpep_i;
            check_and_return(
                dytpep_i >= last_pep_i_start_dytpep_i,
                "last_pep_i_start_dytpep_i inconsistency.");

            last_pep_i_start_dytpep_i = dytpep_i;
            last_pep_i = curr_pep_i;
        }
    }

    // Write the last length
    *u32arr_ptr1(&ctx->pep_i_to_n_dytpeps, last_pep_i) =
        n_dytpeps - last_pep_i_start_dytpep_i;

    // Note that it is expected that some peptides will have no labels
    // and therefore will have no dyts and thus their lookup will be to zero.

    return NULL;
}

char *sample_peps_context_free(SamplePepsContext *ctx) {
    return NULL;
}
