#include "alloca.h"
#include "flann/flann.h"
#include "math.h"
#include "memory.h"
#include "pthread.h"
#include "stdarg.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"
#include "survey_v2.h"

/*

Survey

This code's job is to measure how "isolated" each peptide is
with the goal of quickly prediciting how well a given
label/protease scheme will perform.

*/

void dump_dytpeps(SurveyV2Context *ctx) {
    Index last_pep_i = 0xFFFFFFFFFFFFFFFF;
    for(Index i = 0; i < ctx->dytpeps.n_rows; i++) {
        tab_var(DytPepRec, dytpep, &ctx->dytpeps, i);
        tab_var(Index, mlpep_i, &ctx->dyt_i_to_mlpep_i, dytpep->dyt_i);

        if(last_pep_i != dytpep->pep_i) {
            trace("pep_i%lu\n", dytpep->pep_i);
            last_pep_i = dytpep->pep_i;
        }

        // if(*mlpep_i != dytpep->pep_i) {
        trace(
            "  dyt_i:%-4lu n_reads:%-8lu  mlpep_i:%-4lu   ", dytpep->dyt_i,
            dytpep->n_reads, *mlpep_i);

        tab_var(DytType, dyt, &ctx->dytmat, dytpep->dyt_i);
        for(Index k = 0; k < ctx->dytmat.n_bytes_per_row; k++) {
            trace("%d ", dyt[k]);
        }
        trace("\n");
        //}
    }
}

void dump_row_of_dytmat(Tab *dytmat, int row, char *prefix) {
    tab_var(DytType, dyt, dytmat, row);
    for(Index k = 0; k < dytmat->n_bytes_per_row; k++) {
        printf("%s%d ", prefix, dyt[k]);
    }
    printf("\n");
}

HashKey pep_i_to_hash_key(Index pep_i) {
    return (pep_i + 1);
}

Index hash_key_pep_i(HashKey pep_i) {
    return (pep_i - 1);
}

int show_debug = 0;

void context_pep_measure_isolation(SurveyV2Context *ctx, Index pep_i) {
    /*

    Terminology:
        dyt: Dyttrack
        ml: Most Likely
        mic: Most In Contention
        pep: Peptide
        nn: nearest neighbor
        local_dyts: The dyetracks that are associated with pep_i
            (ie "local" because they pertain only to the input parameter)
        global:dyts: The set of all dyetracks in the simulation.
        ml_pep: "Most Likely Peptide" That is the peptide with the most reads
            from any given dyetrack
        self-dyetrack: a dyetrack that has THIS peptide as its ML-pep
        foreign-dyetrack: a dyetrack that has SOME OTHER peptide as its ML-pep
        isolation: A metric of how well separated this peptide is
            from other peptides. This is a relative metric, not
            an actual distance (ie this is NOT a Euclidiean distance)
        contention: The inverse of isolation. A large number means the
            peptide is LESS isolated.

    This function analyzes the "isolation" of a single peptide.
    It has access to:
        * The dytpeps which is a table w/ columns: (dyt_i, pep_i, n_reads)
            That is, each peptide has a list of all dyetracks it can
            create and how many reads that peptide generated for each
            dyetrack.
        * All the dyetracks

    We seek features for this peptide:
         * A measure of "p_correct"
         * Which OTHER peptide is the most contentious with this peptide?
           (Of the peptides that cause problems, which is the worst?)

    Algorithm:
        For this_peptide...
            for dyt in this_peptide's_dyetracks...
                for neighbor in neighbors_of(dyt)...
                    dist = distance from dyt to neighbor
                    p_not_pred = distance_function(dist)
                        The distance_function is one that goes from
                        0.0 (close by) and asymptotically approaches 1.0
                        as it gets further away. It can be thought of
                        as "probability that this neighbor does NOT predict
                        the peptide"

                        BUT -- the dyt might itself be foreign... so in
                        that case the logic reverses...
                        it's the "probability that this neighbor rescues
                        the predicition of this peptide."
                if dyt is local:
                    p_correct = product( all p_not_pred )
                else if dyt is foreign
                    p_correct = 1 - product( all p_not_pred )

            Each dyt was generated by pep_i n_reads / n_total_reads

            So we now scale each of the p_correct times the fraction
            of calls that dyt contributes to this peptide

            Meanwhile, compute the contention metric for the ml-peptide
            for each dyetrack.
    */

    if(show_debug) {
        trace("pep_i=%ld\n", pep_i);
    }

    Size n_global_dyts = ctx->n_dyts;
    int n_neighbors = ctx->n_neighbors;
    int dyt_row_n_bytes = ctx->dytmat.n_bytes_per_row;
    int n_dyt_cols = ctx->n_dyt_cols;
    ensure(n_dyt_cols > 0, "no n_dyt_cols");

    // SETUP a local table for the dytpeps OF THIS peptide by using the
    // pep_i_to_dytpep_row_i table to get the start and stop range.
    tab_var(
        Index, dytpeps_offset_start_of_this_pep, &ctx->pep_i_to_dytpep_row_i,
        pep_i);
    tab_var(
        Index, dytpeps_offset_start_of_next_pep, &ctx->pep_i_to_dytpep_row_i,
        pep_i + 1);
    int _n_local_dyts =
        *dytpeps_offset_start_of_next_pep - *dytpeps_offset_start_of_this_pep;
    ensure(
        _n_local_dyts > 0, "no dyts pep_i=%ld (this=%ld next=%ld)", pep_i,
        *dytpeps_offset_start_of_this_pep, *dytpeps_offset_start_of_next_pep);
    Index n_local_dyts = (Index)_n_local_dyts;

    // Using the pep_i_to_dytpep_row_i we now have the range of the dytpeps and
    // we can create a table subset (which is jsut a view into the table)
    Tab dytpeps = tab_subset(
        &ctx->dytpeps, *dytpeps_offset_start_of_this_pep, n_local_dyts);

    // We need a contiguous dytmat to feed to the FLANN function so we have
    // to copy each referenced dytmat from the global ctx->dytmat into a local
    // copy. ALLOC a dytmat for all of the dyts of this peptide
    RadType *local_dytmat_buffer =
        (RadType *)alloca(n_local_dyts * n_dyt_cols * sizeof(DytType));
    memset(local_dytmat_buffer, 0, n_local_dyts * n_dyt_cols * sizeof(DytType));
    Tab local_dytmat = tab_by_n_rows(
        local_dytmat_buffer, n_local_dyts, n_dyt_cols * sizeof(DytType),
        TAB_NOT_GROWABLE);

    // LOAD the local dytmat table by copying rows from the global dytmat
    // using the dyt_iz referenced in the dytpeps table.
    for(Index i = 0; i < n_local_dyts; i++) {
        tab_var(DytPepRec, dytpep_row, &dytpeps, i);
        tab_var(DytType, src, &ctx->dytmat, dytpep_row->dyt_i);
        tab_var(DytType, dst, &local_dytmat, i);
        memcpy(dst, src, dyt_row_n_bytes);
    }

    // Now local_dytmat is a contiguous "local" set of the dytmats that
    // are generated by this pep_i. It must be contiguous so that FLANN
    // and operate on it on one fast call.

    // FLANN needs output buffers to write what it found as the closest
    // neighbors and their distances. ALLOC space for those table on the stack
    // because they shouldn't be too large.
    Size nn_dyt_iz_row_n_bytes = n_neighbors * sizeof(int);
    Size nn_dists_row_n_bytes = n_neighbors * sizeof(Float32);
    int *nn_dyt_iz_buf = (int *)alloca(n_local_dyts * nn_dyt_iz_row_n_bytes);
    Float32 *nn_dists_buf =
        (Float32 *)alloca(n_local_dyts * nn_dists_row_n_bytes);
    memset(nn_dyt_iz_buf, 0, n_local_dyts * nn_dyt_iz_row_n_bytes);
    memset(nn_dists_buf, 0, n_local_dyts * nn_dists_row_n_bytes);
    Tab nn_dyt_iz = tab_by_n_rows(
        nn_dyt_iz_buf, n_local_dyts, nn_dyt_iz_row_n_bytes, TAB_NOT_GROWABLE);
    Tab nn_dists = tab_by_n_rows(
        nn_dists_buf, n_local_dyts, nn_dists_row_n_bytes, TAB_NOT_GROWABLE);

    // FETCH a batch of neighbors from FLANN in one call against the GLOBAL
    // index of dyttracks
    int ret = flann_find_nearest_neighbors_index_byte(
        ctx->flann_index_id, tab_ptr(DytType, &local_dytmat, 0), n_local_dyts,
        nn_dyt_iz_buf, nn_dists_buf, n_neighbors, ctx->flann_params);
    ensure(ret == 0, "flann returned error code");

    // At this point FLANN has found neighbors (and their distances) for each
    // local dyttrack and put the results into: 	  Tab nn_dyt_iz contains the
    // GLOBAL dyt_i index for each neighbor 	  Tab nn_dists contains the
    // distance

    Size n_neighbors_u = (Size)n_neighbors;
    Size n_reads_total = 0;

#define N_PEP_HASH_RECS (1024) // increased from 128 after hash table filled up
    Hash contention_by_pep_i =
        hash_init(alloca(sizeof(HashRec) * N_PEP_HASH_RECS), N_PEP_HASH_RECS);
    Index mlpep_i = 0;

    IsolationType isolation_sum = (IsolationType)0.0;
    for(Index dyt_i = 0; dyt_i < n_local_dyts; dyt_i++) {
        // Reminder: dytpeps is the LOCAL dytpeps for pep_i only
        tab_var(DytPepRec, dytpep_row, &dytpeps, dyt_i);

        Index mlpep_i_for_this_dyt_i =
            tab_get(Index, &ctx->dyt_i_to_mlpep_i, dytpep_row->dyt_i);

        // Get pointers to the nearest neighbor (nn) records (closest neighbot
        // dy_y and distance) that FLANN returned to us for this dyt_i
        tab_var(int, nn_dyt_row_i, &nn_dyt_iz, dyt_i);
        tab_var(float, nn_dists_row_i, &nn_dists, dyt_i);

        int is_local = mlpep_i_for_this_dyt_i == pep_i;

        if(show_debug) {
            trace(
                "  dyt_i:%-4lu  n_reads:%-8lu  mlpep_i:%-4lu  is_local:%1d  ",
                dytpep_row->dyt_i, dytpep_row->n_reads, mlpep_i_for_this_dyt_i,
                is_local);

            // DRAW the dyttracl
            tab_var(DytType, dyt, &ctx->dytmat, dytpep_row->dyt_i);
            for(Index k = 0; k < ctx->dytmat.n_bytes_per_row; k++) {
                trace("%d ", dyt[k]);
            }
            trace("\n");
        }

        Index nn_i = 0;
        Index global_dyt_i_of_nn_i = 0;

        Float32 p_product = 1.0f;

        for(nn_i = 0; nn_i < n_neighbors_u; nn_i++) {
            global_dyt_i_of_nn_i = nn_dyt_row_i[nn_i];
            ensure_only_in_debug(
                0 <= (int)global_dyt_i_of_nn_i &&
                    (int)global_dyt_i_of_nn_i < (int)n_global_dyts,
                "Illegal dyt in nn lookup: %ld %ld", global_dyt_i_of_nn_i,
                n_global_dyts);

            if(dytpep_row->dyt_i == global_dyt_i_of_nn_i) {
                // Do not compare a dyttrack to itself, it will always be zero
                continue;
            }

            // LOOKUP the ml-pep for this dyt_i.
            // Remember, we must use the global_dyt_i_of_nn_i not the
            // local_dyt_i
            mlpep_i =
                tab_get(Index, &ctx->dyt_i_to_mlpep_i, global_dyt_i_of_nn_i);
            ensure_only_in_debug(
                0 <= mlpep_i && mlpep_i < ctx->n_peps,
                "mlpep_i out of bounds %ld %ld", mlpep_i, ctx->n_peps);

            IsolationType distance = (IsolationType)nn_dists_row_i[nn_i];
            // Note, FLANN's distances are Manhattan distances (ie sum of the
            // differences of each dimension). I think this is good enough but
            // it might be worth some sort of sweep over distance metrics.

            // This magic number needs to be parameter swept
            // And the function itself is jsut a guess. There are other
            // distance functions that might be better?
            Float32 k = 0.8f;
            Float32 p_func = 1.0f - expf(-k * distance);

            int mode = 0;
            if(!is_local && mlpep_i == pep_i) {
                // A dyt that is foreign but has a neighbor that is local.
                // This is a potential rescue, we product this into
                // the "p of not rescue"
                p_product *= p_func;
                mode = 1;
            }

            if(is_local && mlpep_i != pep_i) {
                // A dyt that is local has a neighbor that is foreign.
                // This is a potential thief, we product this into
                // the "p of not stealing"
                p_product *= p_func;
                mode = 2;
            }

            // Debugging
            if(show_debug && mode != 0) {
                trace(
                    "    nn dyt_i:%-4lu  mlpep_i:%-4lu  dist_to_nn:%7.1f  "
                    "p_func:%7.5f  mode:%1d  dyt_of_nn:",
                    global_dyt_i_of_nn_i, mlpep_i, distance, p_func, mode);

                // Dyetrack
                tab_var(DytType, dyt, &ctx->dytmat, global_dyt_i_of_nn_i);
                for(Index k = 0; k < ctx->dytmat.n_bytes_per_row; k++) {
                    trace("%d ", dyt[k]);
                }
                trace("\n");
            }
        }

        Float32 p_correct;
        if(is_local) {
            // A local dyt has some fraction of reads that are "stolen" by
            // neighbors What the p(no theft)?
            //   p(no theft) = p(nn_0_did_not_steal) * p(nn_1_did_not_steal) ...
            //   p(no theft) = p_product
            p_correct = p_product;
        } else {
            // A foreign dyt has some fraction of reads that are "rescued" by
            // neighbors What the p(any neighbor rescues)?
            //   p(at least one rescue) = 1 - p(no rescue)
            //   p(no rescue) = p(nn_0_did_not_rescue) * p(nn_1_did_not_rescue)
            //   ... p(rescue) = 1 - p_product
            p_correct = 1.0 - p_product;
        }

        IsolationType isolation = dytpep_row->n_reads * p_correct;
        isolation_sum += isolation;
        if(show_debug) {
            trace(
                "    p_correct=%7.5f    isolation=%7.1f \n", p_correct,
                isolation);
        }

        if(!is_local) {
            // This is really just kind of a guess at which peptide
            // is the worst offender...
            // Accumulate into the hash of foreign peps it's contention
            // p_product here is the probability that it wasn't
            // rescued we we're going to assume that if it wasn't
            // rescued that it was assigned to the mlpep.
            // This is not exactly right as some of those neighbors
            // might have assigned to OTHER peptides.

            IsolationType contention = dytpep_row->n_reads * p_product;

            HashKey pep_hash_key = pep_i_to_hash_key(mlpep_i_for_this_dyt_i);
            HashRec *by_pep_i_rec = hash_get(contention_by_pep_i, pep_hash_key);
            if(by_pep_i_rec == (HashRec *)0) {
                // hash full!
                ensure(0, "contention_by_pep_i hash table full");
            } else if(by_pep_i_rec->key == 0) {
                // New record
                by_pep_i_rec->key = pep_hash_key;
                by_pep_i_rec->contention_val = contention;
            } else {
                // Existing record
                by_pep_i_rec->contention_val += contention;
            }
        }

        n_reads_total += dytpep_row->n_reads;
    }

    Float32 p_correct;
    if(n_reads_total > 0) {
        p_correct = isolation_sum / n_reads_total;
    } else {
        p_correct = 0;
    }

    // FIND the most in-contention peptide -- the one with the highest
    // contention
    IsolationType most_contentious = (IsolationType)0.0;
    Index most_contentious_pep_i = 0;
    for(Index i = 0; i < contention_by_pep_i.n_max_recs; i++) {
        Index pep_i_from_hash = hash_key_pep_i(contention_by_pep_i.recs[i].key);
        IsolationType contention_from_hash =
            contention_by_pep_i.recs[i].contention_val;
        if(contention_from_hash > most_contentious) {
            most_contentious = contention_from_hash;
            most_contentious_pep_i = pep_i_from_hash;
        }
    }

    if(show_debug) {
        trace(
            "\n  iso_sum=%7.5f  reads=%-7lu  p_correct=%7.5f "
            "most_contentious_pep_i=%ld\n\n",
            isolation_sum, n_reads_total, p_correct, most_contentious_pep_i);
    }

    // RECORD the results into the output tables
    tab_set(&ctx->output_pep_i_to_isolation_metric, pep_i, &p_correct);
    tab_set(&ctx->output_pep_i_to_mic_pep_i, pep_i, &most_contentious_pep_i);
}

Index context_work_orders_pop(SurveyV2Context *ctx) {
    // TODO: This could be dried with similar sim_v2 code
    // (but remember they refer to differnte SurveyV2FastContext structs)
    // NOTE: This return +1! So that 0 can be reserved.
    if(ctx->n_threads > 1) {
        pthread_mutex_lock(ctx->work_order_lock);
    }

    Index i = ctx->next_pep_i;
    ctx->next_pep_i++;

    if(ctx->n_threads > 1) {
        pthread_mutex_unlock(ctx->work_order_lock);
    }

    if(i < ctx->n_peps) {
        return i + 1;
    }
    return 0;
}

void *context_work_orders_worker(void *_ctx) {
    // The worker thread. Pops off which pep to work on next
    // continues until there are no more work orders.
    SurveyV2Context *ctx = (SurveyV2Context *)_ctx;
    while(1) {
        Index pep_i_plus_1 = context_work_orders_pop(ctx);
        if(pep_i_plus_1 == 0) {
            break;
        }
        Index pep_i = pep_i_plus_1 - 1;

        context_pep_measure_isolation(ctx, pep_i);

        if(pep_i % 100 == 0) {
            // ctx->progress_fn(pep_i, ctx->n_peps, 0);
        }
    }
    // ctx->progress_fn(ctx->n_peps, ctx->n_peps, 0);
    return (void *)0;
}

void context_start(SurveyV2Context *ctx) {
    //    dump_dytpeps(ctx);

    // Initialize mutex and start the worker thread(s).
    ctx->next_pep_i = 0;

    // TODO: DRY with simialr code in nn_v2

    ensure(
        ctx->n_neighbors <= ctx->dytmat.n_rows,
        "FLANN does not support requesting more neihbors than there are data "
        "points");

    // CLEAR internally controlled elements
    ctx->flann_params = &DEFAULT_FLANN_PARAMETERS;
    ctx->flann_index_id = 0;
    ctx->flann_params->cores = ctx->n_flann_cores;

    // CREATE the ANN index
    // TODO: DRY with NN
    float speedup = 0.0f;
    ctx->flann_index_id = flann_build_index_byte(
        tab_ptr(DytType, &ctx->dytmat, 0), ctx->dytmat.n_rows, ctx->n_dyt_cols,
        &speedup, ctx->flann_params);

    // 10/5/2020 DHW changed this to parallelize at the flann level rather than
    // the survey level (n_threads for survey was already set to 1)
    context_work_orders_worker(ctx);

    /*
    // START threads
    // TODO: If threading is enabled, the ctx->work_order_lock will need to be
    malloc'd and free'd pthread_t ids[256]; ensure(0 < ctx->n_threads &&
    ctx->n_threads < 256, "Invalid n_threads");

    if(ctx->n_threads > 1) {
        int ret = pthread_mutex_init(ctx->work_order_lock, NULL);
        ensure(ret == 0, "pthread lock create failed");
    }

    for(Index i=0; i<ctx->n_threads; i++) {
        int ret = pthread_create(&ids[i], NULL, context_work_orders_worker,
    ctx); ensure(ret == 0, "Thread not created.");
    }

    for(Index i=0; i<ctx->n_threads; i++) {
        pthread_join(ids[i], NULL);
    }
    */

    if(show_debug) {
        trace("\nSUMMARY\n");
        for(Index pep_i = 0; pep_i < ctx->n_peps; pep_i++) {
            IsolationType isolation = tab_get(
                IsolationType, &ctx->output_pep_i_to_isolation_metric, pep_i);
            Index mic_pep_i =
                tab_get(Index, &ctx->output_pep_i_to_mic_pep_i, pep_i);
            trace(
                "  pep:%-4lu  p_correct:%7.4f  mic_pep:%-4lu\n", pep_i,
                isolation, mic_pep_i);
        }
    }
}
