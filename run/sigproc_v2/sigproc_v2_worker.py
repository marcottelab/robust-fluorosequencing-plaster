"""
This is the Signal Processor that extracts data from images from the fluoro-sequencer microscope.

Nomenclature
    Field
        One position of the X/Y stage
    Channel
        One wavelength of measured light
    Cycle
        One chemical cycle (Pre, Mock or Edman)
    Anomaly
        An area of an image that has a problem (dust, etc)
    Raw image
        Unmodified images from the scope
    Regional
        When any parameter is varies spatially (PSF, IlluminationBalance)
    Balance image
        A raw image scaled to compensate for regional uneven illumination.
    Aligned field stack
        The stage is not perfect and does not return to exactly the same position
        each cycle so a computational alignment correction finds the optimal X/Y translation
        with sub-pixel accuracy.
    ROI
        A Region Of Interest
    Intersection ROI
        In an aligned field stack, the Intersection ROI is the set
        of pixels that are in every cycle.  Ie, typically smaller than the
        dimensions of the raw images.
    Composite image
        When one or more of the channels/cycles for a field are stacked
    Fiducial images
        An image that is intended only to enhance the alignment or
        peak finding algorithm. These images are temporary and discarded after use.
    PSF
        Point Spread Function. The little image used during radiometry
    Approximate PSF
        A close-enough estimate of the PSF used for peak finding
    Peak/Loc/Spot
        A Peak, LOC-action, or Spot found in the image that presumably
        is generated by a single molecule.
        A loc generally means the y,x location of a peak/spot
        Peak and Spot are the more general terms for some sort of bright
        area that we want to analyze
    Radmat (aka "Radiometry Matrix")
        A matrix such that each row is a peak and each column is a measurement of brightness
        for each channel/cycle.
        Sometimes stored in (n_peaks, n_channels, n_cycles)
        Sometimes stored flatten as (n_peaks, n_channels * n_cycles)
    Radrow
        A single row (corresponding to a single peak) of a radmat.
    cy_ims
        A set of images through all cycles for one field/channel.
    chcy_ims
        A set of images for all channel/cycles for one field.
    flchcy_ims
        A set of images for all field/channel/cycles.


Calibrations
    Calibrations are run occasionally and inform later analysis
        * Regional Illumination Balance
        * Regional PSF
        * Channel-to-channel alignment

Analysis
    Analysis is run on "real" data (as opposed to calibrations)
    It may use a calibration --or--
        "no calibrate":
            where defaults are used for balancing, PSFs, etc.
        "self calibrate" where the run itself is used as both the
            calibration and the analysis

"""
import pathlib
import typing
from dataclasses import dataclass
from logging import getLogger

import numpy as np
import pandas as pd
from munch import Munch

from plaster.run import priors
from plaster.run.ims_import.ims_import_result import ImsImportResult
from plaster.run.sigproc_v2 import peak_find, psf
from plaster.run.sigproc_v2 import sigproc_v2_common as common
from plaster.run.sigproc_v2 import sigproc_v2_null_hypothesis
from plaster.run.sigproc_v2.align_ims import align_ims, resample_aligned_ims
from plaster.run.sigproc_v2.c_gauss2_fitter.gauss2_fitter import Gauss2FitParams
from plaster.run.sigproc_v2.c_radiometry.radiometry import radiometry_cy_ims
from plaster.run.sigproc_v2.filter_ims import filter_im
from plaster.run.sigproc_v2.peak_fit import fit_peaks_one_im
from plaster.run.sigproc_v2.sigproc_v2_params import SigprocV2Params
from plaster.run.sigproc_v2.sigproc_v2_result import SigprocV2ResultDC
from plaster.tools.pipeline.pipeline import Progress
from plaster.tools.schema import check
from plaster.tools.utils import utils
from plaster.tools.zap import zap
from plaster.tools.zlog.profile import prof, prof_start, prof_stop

log = getLogger(__name__)


# Calibration
# ---------------------------------------------------------------------------------------------


def _do_calibrate_reg_illum_one_field(
    ch_i, fl_i, ims_import_result, sigproc_v2_params, reg_psf_samples
):
    approx_psf = psf.approximate_psf()

    cy_i = 0
    im = ims_import_result.ims[fl_i, ch_i, cy_i]

    # FILTER
    filtered_im = filter_im(
        im,
        low_inflection=sigproc_v2_params.low_inflection,
        low_sharpness=sigproc_v2_params.low_sharpness,
        high_inflection=sigproc_v2_params.high_inflection,
        high_sharpness=sigproc_v2_params.high_sharpness,
    )

    filtered_im = filtered_im.astype(np.float64)

    # PEAK FIND
    locs = peak_find.pixel_peak_find_one_im(filtered_im, approx_psf)
    locs = locs.astype(np.float64)

    # RADIOMETRY

    # radiometry_field_stack is optimized to take a cycle stack
    # but in the case of reg_illum we have only a single image
    # because in this case we don't align. So we stub out the
    # extract dimension.
    cy_ims = np.ascontiguousarray(filtered_im[None, :, :])

    radmat = radiometry_cy_ims(
        cy_ims, locs, reg_psf_samples, sigproc_v2_params.peak_mea, ch_i
    )

    # Return an array of (loc_y, loc_x, radiometry).
    # The radiometry is [
    #   : -- all_peaks,
    #   0 -- cycle 0 (because of stub above),
    #   0 -- signal (which is 0 in the tuple of sig, noise, snr, asr)
    # ]
    peak_locs_rads = np.stack((locs[:, 0], locs[:, 1], radmat[:, 0, 0]), axis=1)
    return peak_locs_rads


@dataclass
class CalibrationParams:
    calib_priors: priors.Priors
    field_iz: typing.Iterable[int]
    ims_import_result: ImsImportResult
    sigproc_v2_params: SigprocV2Params


def _calibrate_align(params: CalibrationParams) -> priors.ChannelAlignPrior:
    aln_per_field = []

    # TODO: Zap?
    for fl_i in params.field_iz:
        aln_per_field += [
            align_ims(params.ims_import_result.ims[fl_i, :, 0].astype(float))
        ]

    # Mean over all fields
    aln_per_field = np.array(aln_per_field)
    ch_aln = np.mean(aln_per_field, axis=0)

    ch_aln_prior = priors.ChannelAlignPrior(params.ims_import_result.n_channels)
    ch_aln_prior.set(ch_aln)

    return ch_aln_prior


def _calibrate_regional_psf(
    params: CalibrationParams,
) -> typing.Generator[typing.Tuple[int, priors.RegPSFPrior], None, None]:

    for ch_i in range(0, params.ims_import_result.n_channels):
        yield (
            ch_i,
            psf.psf_fields_one_channel(
                params.ims_import_result,
                params.sigproc_v2_params,
                params.field_iz,
                ch_i,
            ),
        )


def _calibrate_regional_illumination(
    params: CalibrationParams,
) -> typing.Generator[typing.Tuple[int, priors.RegIllumPrior], None, None]:

    approx_field_memory = (
        params.ims_import_result.dim**2  # n_pixels
        * 1  # n_channel at a time
        * params.ims_import_result.n_cycles  # n_cycles
        * 8  # sizeof(float64)
        * 5  # working space
    )

    for ch_i in range(params.ims_import_result.n_channels):
        reg_illum = priors.RegIllumPrior(hyper_im_mea=params.ims_import_result.dim)
        reg_psf = params.calib_priors.get(f"reg_psf.ch_{ch_i}").prior
        reg_psf_samples = reg_psf.sample_params_grid(n_divs=32)

        with zap.Context(
            trap_exceptions=False,
            mem_per_workorder=approx_field_memory,
        ):
            # Each field returns an array which contains (loc_y, loc_x, radiometry)
            # These are combined into one large array and used as the input to the
            # geometry fitter

            peak_locs_rads_per_field = zap.work_orders(
                [
                    Munch(
                        fn=_do_calibrate_reg_illum_one_field,
                        ch_i=ch_i,
                        fl_i=field_i,
                        ims_import_result=params.ims_import_result,
                        sigproc_v2_params=params.sigproc_v2_params,
                        reg_psf_samples=reg_psf_samples,
                    )
                    for field_i in params.field_iz
                ]
            )

            peak_locs_rads = np.concatenate(peak_locs_rads_per_field)

            try:
                reg_illum.estimate(peak_locs_rads)
            except (AssertionError, check.CheckError, ValueError, RuntimeError) as e:
                raise Exception(
                    f"Channel {ch_i} failed to calibrate the regional illumination "
                    f"balance. There were {peak_locs_rads.shape[0]} peaks. "
                    f"Perhaps there was too little data? "
                    f"Consider limiting the number of input channels to avoid "
                    f"this channel."
                ) from e

        yield (ch_i, reg_illum)


def _calibrate_field_iz(
    ims_import_result: ImsImportResult,
    sigproc_v2_params: SigprocV2Params,
) -> typing.Iterable[int]:

    if (
        sigproc_v2_params.n_fields_limit is not None
        and sigproc_v2_params.n_fields_limit > 0
    ):
        return list(range(sigproc_v2_params.n_fields_limit))

    # TODO: write test case for this block
    # Use quality metrics
    q = ims_import_result.qualities()
    if len(q) > 0:
        q_by_field = q.groupby("field_i").quality.mean()
        if len(q_by_field) > 20:
            # If we have lots of fields then OK to take only the best ones
            # Otherwise use all fields for calibration
            med_field_q = np.median(q_by_field.values)
            return q_by_field[q_by_field > med_field_q].index.values

    return list(range(ims_import_result.n_fields))


def _calibrate(
    ims_import_result: ImsImportResult,
    sigproc_v2_params: SigprocV2Params,
) -> priors.Priors:
    """
    The guts of calibration without making a result task object and saving it.

    Extract a Regional PSF and Regional Illumination balance.

    PSF is extracted first because the RegIllum requires it for
    extracting radiometry which it uses for regional brightness

    Returns:
        dict: {prior_name: Prior}
    """

    # Select fields
    # -----------------------------------

    params = CalibrationParams(
        calib_priors=priors.Priors(),
        field_iz=_calibrate_field_iz(ims_import_result, sigproc_v2_params),
        ims_import_result=ims_import_result,
        sigproc_v2_params=sigproc_v2_params,
    )

    # CH Align
    # -----------------------------------

    params.calib_priors.add(
        "ch_aln",
        _calibrate_align(params),
        source="channel_align",
    )

    # PSF
    # -----------------------------------

    for (ch_i, reg_psf) in _calibrate_regional_psf(params):
        params.calib_priors.add(f"reg_psf.ch_{ch_i}", reg_psf, source="calib_psf")

    # Regional Illumination
    # -----------------------------------

    # This is like a typical (non calibration) analysis in that
    # it needs to filter, peak find, and compute radiometry
    # but it differs in that it doesn't align.
    # It then uses the point estimates of radiometry to fit
    # a simpler geometric function to the regional illumination.
    # This is zapped over fields

    for (ch_i, reg_illum) in _calibrate_regional_illumination(params):
        params.calib_priors.add(
            f"reg_illum.ch_{ch_i}",
            reg_illum,
            source="calib_illum",
        )

    return params.calib_priors


def calibrate(
    sigproc_v2_params: SigprocV2Params,
    ims_import_result: ImsImportResult,
    result_class: SigprocV2ResultDC = SigprocV2ResultDC,
    folder: pathlib.Path = None,
) -> SigprocV2ResultDC:
    """
    Entrypoint for Illumination and PSF calibration.
    """

    assert sigproc_v2_params.mode == common.SIGPROC_V2_ILLUM_CALIB
    calib_priors = _calibrate(
        ims_import_result,
        sigproc_v2_params,
    )
    allowed_calib_priors = ["ch_aln", "reg_illum", "reg_psf"]

    for name in calib_priors.enumerate_names():
        name_stem = name.split(".")[0]
        assert (
            name_stem in allowed_calib_priors
        ), f"{name_stem} not one of valid values: {allowed_calib_priors}"

    sigproc_v2_result = result_class(
        params=sigproc_v2_params,
        n_channels=0,
        n_cycles=0,
        n_fields=0,
    )

    sigproc_v2_result._calib_priors.set(calib_priors)

    if folder is not None:
        sigproc_v2_result.set_folder(folder)

    sigproc_v2_result.save()
    return sigproc_v2_result


# Analysis
# -------------------------------------------------------------------------------


@dataclass
class AnalyzeFieldResult:
    aln_filt_chcy_ims: np.ndarray
    aln_unfilt_chcy_ims: np.ndarray
    loc_df: pd.DataFrame
    locs: np.ndarray
    radmat: np.ndarray
    aln_offsets: np.ndarray
    fitmat: np.ndarray
    locs_per_channel: typing.List[np.ndarray]
    cy_locs: typing.Optional[typing.List[np.ndarray]]


def _analyze_field(raw_chcy_ims, sigproc_v2_params) -> AnalyzeFieldResult:
    """
    Analyze one field --
        * Regional balance using RegIllum from calibration
        * Remove anomalies (temporarily removed)
        * Align
            - Shift channel-to-channel alignment from calibration
            - Find sub-pixel alignment through cycles from sum of all channels
            - Resample aligned images with sub-pixel accuracy
        * Peak find (sub-pixel on resampled aligned images)
        * Fit peaks (optional)
            - Typically only a subset used for focal debugging
        * Radiometry
            - For each peak_im, lookup local PSF params from RegPSF from calibration
            - Render PSF with sub-pixel precision using COM estimate from image
            - Multiply psf_im and peak_im to get signal and noise
        * Filtering (temporarily removed)

    Arguments:
        raw_chcy_ims: from ims_import_result
        sigproc_v2_params: The SigprocParams
    """

    # Step 1: Load the images in output channel order, filter, and balance
    # --------------------------------------------------------------------

    chcy_ims = raw_chcy_ims.astype(np.float64)
    n_channels, n_cycles, dim_h, dim_w = chcy_ims.shape
    assert dim_h == dim_w
    dim = (dim_w, dim_w)

    prof_start("analyze_field", n_chcy=n_channels * n_cycles)

    filt_chcy_ims = np.zeros((n_channels, n_cycles, *dim))
    unfilt_chcy_ims = np.zeros((n_channels, n_cycles, *dim))

    # Step 1: Filter
    # ---------------------------------

    with prof("filter"):
        for ch_i in range(n_channels):
            reg_illum = sigproc_v2_params.priors.get_distr(f"reg_illum.ch_{ch_i}")
            bal_im = np.ones(dim)
            if sigproc_v2_params.run_regional_balance:
                bal_im = reg_illum.render()
                assert bal_im.sum() > 0.0, "Sanity check"

            for cy_i in range(n_cycles):
                regionally_balanced_im = chcy_ims[ch_i, cy_i] / bal_im

                filtered_im = filter_im(
                    regionally_balanced_im,
                    low_inflection=sigproc_v2_params.low_inflection,
                    low_sharpness=sigproc_v2_params.low_sharpness,
                    high_inflection=sigproc_v2_params.high_inflection,
                    high_sharpness=sigproc_v2_params.high_sharpness,
                )

                unfilt_chcy_ims[ch_i, cy_i, :, :] = regionally_balanced_im
                filt_chcy_ims[ch_i, cy_i, :, :] = filtered_im

    # Step 2: Align, sub-pixel resample
    # ---------------------------------

    with prof("align"):
        ch_aln = sigproc_v2_params.priors.get_distr("ch_aln").ch_aln
        alignment = np.zeros((n_channels, n_cycles, 2))

        if (
            sigproc_v2_params.ch_for_alignment is not None
            and sigproc_v2_params.ch_for_alignment >= 0
        ):
            # This is a special param option that allows using
            # a single channel as the only alignment source.
            # Useful for the boundary case when some channels
            # do not have much signal and would fail alignment
            # The need for this will eventually be deprecated
            # once an intensity-free composite alignment is implemented.
            master_ch_i = sigproc_v2_params.ch_for_alignment
            align_master_ch = align_ims(filt_chcy_ims[master_ch_i])
            for ch_i in range(n_channels):
                alignment[ch_i, :, :] = align_master_ch + ch_aln[ch_i]
        else:
            for ch_i in range(n_channels):
                alignment[ch_i, :, :] = align_ims(filt_chcy_ims[ch_i]) + ch_aln[ch_i]

        with prof("resample"):
            aln_filt_chcy_ims = resample_aligned_ims(filt_chcy_ims, alignment)
            aln_unfilt_chcy_ims = resample_aligned_ims(unfilt_chcy_ims, alignment)

        assert aln_filt_chcy_ims.shape[-2:] == dim
        assert aln_unfilt_chcy_ims.shape[-2:] == dim

    # Step 3: Find peaks
    # ------------------

    with prof("peak_find"):
        approx_psf = psf.approximate_psf()

        if sigproc_v2_params.run_fast_peak_finder:
            pf_result = peak_find.peak_find_chcy_ims_fast(
                aln_filt_chcy_ims, approx_psf, cycle_i=0, subpixel=True
            )
        else:
            pf_result = peak_find.peak_find_chcy_ims(
                aln_filt_chcy_ims,
                approx_psf,
                cycle_i=0,
                subpixel=True,
            )
        n_locs = len(pf_result.locs)

        cy_locs = None
        if sigproc_v2_params.run_per_cycle_peakfinder:
            cy_locs = []
            for cy_i in range(n_cycles):
                # Use the faster pixel peak finder as we don't need accuracy
                # on these calls, just counts
                cy_locs += [
                    peak_find.peak_find_chcy_ims(
                        aln_filt_chcy_ims, approx_psf, cycle_i=cy_i, subpixel=False
                    ).locs
                ]

    # Step 4: Fit all or some peaks with Gaussian fitter
    # --------------------------------------------------

    with prof("peak_fit"):
        if sigproc_v2_params.run_analysis_gauss2_fitter:
            # If requested, fit all peaks with fitter (used for debugging purposes)
            fitter_mask = np.ones((n_locs,), dtype=bool)

        elif sigproc_v2_params.run_minimal_analysis_gauss2_fitter:
            # Subsample peak fits used to diagnose focus issues
            fitter_mask = np.zeros((n_locs,), dtype=bool)
            count = 250
            if n_locs > 0:
                try:
                    # Allow replace in case count > n_locs
                    iz = np.random.choice(n_locs, count, replace=True)
                    fitter_mask[iz] = 1
                except ValueError:
                    pass
        else:
            fitter_mask = np.zeros((n_locs,), dtype=bool)

        check.array_t(fitter_mask, shape=(pf_result.locs.shape[0],), dtype=bool)

        fitmat = np.full(
            (n_locs, n_channels, n_cycles, Gauss2FitParams.N_FULL_PARAMS), np.nan
        )

        # Set all the locs that will not be fit to NaN: This disables
        # the fitter in the fit_peaks_one_im()
        fit_locs = pf_result.locs.copy()
        fit_locs[~fitter_mask, :] = np.nan
        for ch_i in range(n_channels):
            reg_psf = sigproc_v2_params.priors.get_distr(f"reg_psf.ch_{ch_i}")
            for cy_i in range(n_cycles):
                regionally_balanced_im = aln_filt_chcy_ims[ch_i, cy_i]
                fitmat[:, ch_i, cy_i, :] = fit_peaks_one_im(
                    regionally_balanced_im, fit_locs, reg_psf
                )

    # Step 5: Radiometry
    # ------------------

    with prof("radiometry"):
        radmat_per_ch = []
        for ch_i in range(n_channels):
            reg_psf = sigproc_v2_params.priors.get_distr(f"reg_psf.ch_{ch_i}")
            reg_psf_samples = reg_psf.sample_params_grid(n_divs=32)
            radmat_per_ch += [
                # MAJOR problem here for FRET,
                # We are using the ch_locs below.
                # But in FRET runs we are violating our assumption
                # that peaks must be present in cycle 0
                # because int he FRET channel they don't appear until later.
                # and the ch_locs business has no values for the channel
                # We need some kind of warning here?
                # You shouldn't ever be running radiometry on a NAN value!
                # And furthermore, we want to use the canonical locs for
                # not the ch_loc in these cases!
                # I think the right hack -- given that this is all going to
                # so away in _v3 -- is that we use the canonical locs here.
                radiometry_cy_ims(
                    aln_filt_chcy_ims[ch_i],
                    # np.ascontiguousarray(pf_result.ch_locs(ch_i)),
                    np.ascontiguousarray(pf_result.locs),
                    reg_psf_samples,
                    reg_psf.hyper_peak_mea,
                    ch_i=ch_i,
                )
            ]

        radmat = np.stack(radmat_per_ch, axis=1)

    prof_stop()

    return AnalyzeFieldResult(
        aln_filt_chcy_ims=aln_filt_chcy_ims,
        aln_unfilt_chcy_ims=aln_unfilt_chcy_ims,
        loc_df=pf_result.loc_df,
        locs=pf_result.locs,
        radmat=radmat,
        aln_offsets=alignment,
        fitmat=fitmat,
        locs_per_channel=pf_result.locs_per_channel,
        cy_locs=cy_locs,
    )


def _do_analyze_and_save_field(
    field_i, ims_import_result, sigproc_v2_params, sigproc_v2_result, _save_debug=True
):
    """
    Analyze AND SAVE one field by calling the sigproc_v2_result.save_field()
    """

    chcy_ims = ims_import_result.ims[field_i]
    n_channels, n_cycles, roi_h, roi_w = chcy_ims.shape

    af_result = _analyze_field(chcy_ims, sigproc_v2_params)

    mea = np.array([chcy_ims.shape[-1:]])
    bad_align_mask = af_result.aln_offsets**2 > (mea * 0.2) ** 2
    # if np.any(bad_align_mask):
    #     log.info(
    #         f"field {field_i} has bad alignment @(ch,cy,dim[h,w])\n"
    #         f"{np.argwhere(bad_align_mask)}\n"
    #         f"with values:\n"
    #         f"{aln_offsets[bad_align_mask]}"
    #     )

    # Assign 0 to "peak_i" in the following DF because that is the GLOBAL peak_i
    # which is not computable until all fields are processed. It will be fixed up later
    # by the SigprocV2ResultDC helper methods
    peak_df = pd.DataFrame(
        [
            (0, field_i, peak_i, loc[0], loc[1])
            for peak_i, loc in enumerate(af_result.locs)
        ],
        columns=list(SigprocV2ResultDC.peak_df_schema.keys()),
    )

    field_df = pd.DataFrame(
        [
            (
                field_i,
                ch_i,
                cy_i,
                af_result.aln_offsets[ch_i, cy_i, 0],
                af_result.aln_offsets[ch_i, cy_i, 1],
            )
            for ch_i in range(n_channels)
            for cy_i in range(n_cycles)
        ],
        columns=list(SigprocV2ResultDC.field_df_schema.keys()),
    )

    sigproc_v2_result.save_field(
        field_i,
        _save_debug=_save_debug,
        peak_df=peak_df,
        field_df=field_df,
        radmat=af_result.radmat,
        fitmat=af_result.fitmat,
        cy_locs=af_result.cy_locs,
        _aln_filt_chcy_ims=af_result.aln_filt_chcy_ims,
        _aln_unfilt_chcy_ims=af_result.aln_unfilt_chcy_ims,
        aln_offsets=af_result.aln_offsets,
        loc_df=af_result.loc_df,
        locs_per_channel=af_result.locs_per_channel,
        im_mea=roi_h,
    )


def analyze(
    sigproc_v2_params: SigprocV2Params,
    ims_import_result: ImsImportResult,
    folder=None,
    result_class=SigprocV2ResultDC,
):
    """
    Entrypoint for analysis.

    folder only non-None in special cases
    """

    prof_start("sigproc_v2")

    calib_priors = None
    if sigproc_v2_params.self_calib:
        with Progress("calibrate") as progress:
            calib_priors = _calibrate(ims_import_result, sigproc_v2_params)

        # Do not allow self_calib to over-ride the priors in the _params
        if sigproc_v2_params.ch_aln_override:
            calib_priors.remove("ch_aln")

        sigproc_v2_params.priors.update(calib_priors, "self_calib")

    # ch_aln_override is a special hack to temporarily bypass calibration
    if sigproc_v2_params.ch_aln_override:
        ch_aln_arr = np.array(sigproc_v2_params.ch_aln_override).reshape((-1, 2))
        n_channels = ch_aln_arr.shape[0]
        ch_aln_prior = priors.ChannelAlignPrior(n_channels)
        ch_aln_prior.set(ch_aln_arr)
        sigproc_v2_params.priors.add("ch_aln", ch_aln_prior, "ch_aln_override")

    n_fields = ims_import_result.n_fields
    n_fields_limit = sigproc_v2_params.n_fields_limit
    if n_fields_limit is not None and n_fields_limit > 0 and n_fields_limit < n_fields:
        n_fields = n_fields_limit

    sigproc_v2_result = result_class(
        params=sigproc_v2_params,
        n_fields=n_fields,
        n_channels=ims_import_result.n_channels,
        n_cycles=ims_import_result.n_cycles,
    )

    sigproc_v2_result._calib_priors.set(calib_priors)

    if folder:
        sigproc_v2_result.set_folder(folder)

    approx_field_memory = (
        ims_import_result.dim**2  # n_pixels
        * ims_import_result.n_channels  # n_channels
        * ims_import_result.n_cycles  # n_cycles
        * 8  # sizeof(float64)
        * 2  # filtered and unfiltered
        * 5  # working space
    )

    field_list = list(range(n_fields))

    dev_force_field_list = False
    if dev_force_field_list:
        # Use this to debug a specific field
        field_list = (20,)
        log.warning(f"USING DEBUG MODE LIMIT OF FIELD_LIST: {field_list}")

    with Progress("analyze") as progress:
        with prof("analyze", n_fields=len(field_list), _group_children_by="field_i"):
            with zap.Context(
                trap_exceptions=False,
                progress=progress,
                mem_per_workorder=approx_field_memory,
            ):
                zap.work_orders(
                    [
                        Munch(
                            fn=_do_analyze_and_save_field,
                            field_i=field_i,
                            ims_import_result=ims_import_result,
                            sigproc_v2_params=sigproc_v2_params,
                            sigproc_v2_result=sigproc_v2_result,
                        )
                        for field_i in field_list
                    ]
                )

    if sigproc_v2_params.null_hypothesis_precompute:
        # This is an ugly hack to get the first field. Can't use the normal way here
        field0 = utils.indexed_pickler_load(
            sigproc_v2_result._folder / sigproc_v2_result._field_filename(0, False)
        )

        with Progress("precompute null hypothesis") as progress:

            with prof("null_hypothesis_precompute"):

                # TODO: set bg_mean and bg_std to values based on field0
                synth_params = sigproc_v2_null_hypothesis.SynthParams(
                    n_channels=ims_import_result.n_channels, im_mea=field0["im_mea"]
                )

                sigproc_v2_result.null_hypothesis_precompute = (
                    sigproc_v2_null_hypothesis.precompute_null_hypothesis(
                        actual_discovered_peaks=len(field0["loc_df"].index),
                        synth_params=synth_params,
                        sigproc_v2_params=sigproc_v2_params,
                        progress=progress,
                    )
                )
    else:
        sigproc_v2_result.null_hypothesis_precompute = None

    sigproc_v2_result.save(
        save_full_signal_radmat_npy=sigproc_v2_params.save_full_signal_radmat_npy
    )

    prof_stop()

    return sigproc_v2_result
